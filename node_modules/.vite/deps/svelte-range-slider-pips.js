import "./chunk-EMTS6HMJ.js";
import {
  spring
} from "./chunk-CNMHVUA7.js";
import "./chunk-VESTXBSL.js";
import "./chunk-VFRMSNTO.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  add_location,
  append_dev,
  append_styles,
  attr_dev,
  binding_callbacks,
  check_outros,
  createEventDispatcher,
  create_component,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  globals,
  group_outros,
  init,
  insert_dev,
  listen_dev,
  mount_component,
  noop,
  prevent_default,
  run_all,
  safe_not_equal,
  set_data_dev,
  space,
  subscribe,
  text,
  toggle_class,
  transition_in,
  transition_out,
  validate_slots
} from "./chunk-QKJLOYRO.js";
import "./chunk-ZUGQ3PSC.js";
import "./chunk-TYRVL62N.js";

// node_modules/svelte-range-slider-pips/src/RangePips.svelte
var file = "node_modules/svelte-range-slider-pips/src/RangePips.svelte";
function add_css(target) {
  append_styles(target, "svelte-19a3n3k", ".rangeSlider{--pip:var(--range-pip, lightslategray);--pip-text:var(--range-pip-text, var(--pip));--pip-active:var(--range-pip-active, darkslategrey);--pip-active-text:var(--range-pip-active-text, var(--pip-active));--pip-hover:var(--range-pip-hover, darkslategrey);--pip-hover-text:var(--range-pip-hover-text, var(--pip-hover));--pip-in-range:var(--range-pip-in-range, var(--pip-active));--pip-in-range-text:var(--range-pip-in-range-text, var(--pip-active-text))}.rangePips{position:absolute;height:1em;left:0;right:0;bottom:-1em}.rangePips.vertical{height:auto;width:1em;left:100%;right:auto;top:0;bottom:0}.rangePips .pip{height:0.4em;position:absolute;top:0.25em;width:1px;white-space:nowrap}.rangePips.vertical .pip{height:1px;width:0.4em;left:0.25em;top:auto;bottom:auto}.rangePips .pipVal{position:absolute;top:0.4em;transform:translate(-50%, 25%)}.rangePips.vertical .pipVal{position:absolute;top:0;left:0.4em;transform:translate(25%, -50%)}.rangePips .pip{transition:all 0.15s ease}.rangePips .pipVal{transition:all 0.15s ease, font-weight 0s linear}.rangePips .pip{color:lightslategray;color:var(--pip-text);background-color:lightslategray;background-color:var(--pip)}.rangePips .pip.selected{color:darkslategrey;color:var(--pip-active-text);background-color:darkslategrey;background-color:var(--pip-active)}.rangePips.hoverable:not(.disabled) .pip:hover{color:darkslategrey;color:var(--pip-hover-text);background-color:darkslategrey;background-color:var(--pip-hover)}.rangePips .pip.in-range{color:darkslategrey;color:var(--pip-in-range-text);background-color:darkslategrey;background-color:var(--pip-in-range)}.rangePips .pip.selected{height:0.75em}.rangePips.vertical .pip.selected{height:1px;width:0.75em}.rangePips .pip.selected .pipVal{font-weight:bold;top:0.75em}.rangePips.vertical .pip.selected .pipVal{top:0;left:0.75em}.rangePips.hoverable:not(.disabled) .pip:not(.selected):hover{transition:none}.rangePips.hoverable:not(.disabled) .pip:not(.selected):hover .pipVal{transition:none;font-weight:bold}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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 */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[37] = list[i];
  child_ctx[39] = i;
  return child_ctx;
}
function create_if_block_9(ctx) {
  let span;
  let span_style_value;
  let mounted;
  let dispose;
  let if_block = (
    /*all*/
    (ctx[6] === "label" || /*first*/
    ctx[7] === "label") && create_if_block_10(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      attr_dev(span, "class", "pip first");
      attr_dev(span, "style", span_style_value = /*orientationStart*/
      ctx[14] + ": 0%;");
      toggle_class(
        span,
        "selected",
        /*isSelected*/
        ctx[18](
          /*min*/
          ctx[0]
        )
      );
      toggle_class(
        span,
        "in-range",
        /*inRange*/
        ctx[17](
          /*min*/
          ctx[0]
        )
      );
      add_location(span, file, 202, 4, 5392);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      if (!mounted) {
        dispose = [
          listen_dev(
            span,
            "pointerdown",
            /*pointerdown_handler*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            span,
            "pointerup",
            /*pointerup_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*all*/
        ctx2[6] === "label" || /*first*/
        ctx2[7] === "label"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_10(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*orientationStart*/
      16384 && span_style_value !== (span_style_value = /*orientationStart*/
      ctx2[14] + ": 0%;")) {
        attr_dev(span, "style", span_style_value);
      }
      if (dirty[0] & /*isSelected, min*/
      262145) {
        toggle_class(
          span,
          "selected",
          /*isSelected*/
          ctx2[18](
            /*min*/
            ctx2[0]
          )
        );
      }
      if (dirty[0] & /*inRange, min*/
      131073) {
        toggle_class(
          span,
          "in-range",
          /*inRange*/
          ctx2[17](
            /*min*/
            ctx2[0]
          )
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(202:2) {#if ( all && first !== false ) || first }",
    ctx
  });
  return block;
}
function create_if_block_10(ctx) {
  let span;
  let t_value = (
    /*formatter*/
    ctx[12](
      /*fixFloat*/
      ctx[16](
        /*min*/
        ctx[0]
      ),
      0,
      0
    ) + ""
  );
  let t;
  let if_block0 = (
    /*prefix*/
    ctx[10] && create_if_block_12(ctx)
  );
  let if_block1 = (
    /*suffix*/
    ctx[11] && create_if_block_11(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block0)
        if_block0.c();
      t = text(t_value);
      if (if_block1)
        if_block1.c();
      attr_dev(span, "class", "pipVal");
      add_location(span, file, 211, 8, 5692);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (if_block0)
        if_block0.m(span, null);
      append_dev(span, t);
      if (if_block1)
        if_block1.m(span, null);
    },
    p: function update(ctx2, dirty) {
      if (
        /*prefix*/
        ctx2[10]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          if_block0.m(span, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & /*formatter, fixFloat, min*/
      69633 && t_value !== (t_value = /*formatter*/
      ctx2[12](
        /*fixFloat*/
        ctx2[16](
          /*min*/
          ctx2[0]
        ),
        0,
        0
      ) + ""))
        set_data_dev(t, t_value);
      if (
        /*suffix*/
        ctx2[11]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_11(ctx2);
          if_block1.c();
          if_block1.m(span, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(211:6) {#if all === 'label' || first === 'label'}",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*prefix*/
        ctx[10]
      );
      attr_dev(span, "class", "pipVal-prefix");
      add_location(span, file, 212, 22, 5736);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*prefix*/
      1024)
        set_data_dev(
          t,
          /*prefix*/
          ctx2[10]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(213:10) {#if prefix}",
    ctx
  });
  return block;
}
function create_if_block_11(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*suffix*/
        ctx[11]
      );
      attr_dev(span, "class", "pipVal-suffix");
      add_location(span, file, 212, 112, 5826);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*suffix*/
      2048)
        set_data_dev(
          t,
          /*suffix*/
          ctx2[11]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_11.name,
    type: "if",
    source: "(213:100) {#if suffix}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let each_1_anchor;
  let each_value = ensure_array_like_dev(Array(
    /*pipCount*/
    ctx[20] + 1
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*orientationStart, percentOf, pipVal, isSelected, inRange, labelDown, labelUp, suffix, formatter, prefix, all, rest, min, max, pipCount*/
      8314435) {
        each_value = ensure_array_like_dev(Array(
          /*pipCount*/
          ctx2[20] + 1
        ));
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(219:2) {#if ( all && rest !== false ) || rest}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let span;
  let t;
  let span_style_value;
  let mounted;
  let dispose;
  let if_block = (
    /*all*/
    (ctx[6] === "label" || /*rest*/
    ctx[9] === "label") && create_if_block_6(ctx)
  );
  function pointerup_handler_1(...args) {
    return (
      /*pointerup_handler_1*/
      ctx[33](
        /*i*/
        ctx[39],
        ...args
      )
    );
  }
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      t = space();
      attr_dev(span, "class", "pip");
      attr_dev(span, "style", span_style_value = /*orientationStart*/
      ctx[14] + ": " + /*percentOf*/
      ctx[15](
        /*pipVal*/
        ctx[19](
          /*i*/
          ctx[39]
        )
      ) + "%;");
      toggle_class(
        span,
        "selected",
        /*isSelected*/
        ctx[18](
          /*pipVal*/
          ctx[19](
            /*i*/
            ctx[39]
          )
        )
      );
      toggle_class(
        span,
        "in-range",
        /*inRange*/
        ctx[17](
          /*pipVal*/
          ctx[19](
            /*i*/
            ctx[39]
          )
        )
      );
      add_location(span, file, 221, 8, 6065);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      append_dev(span, t);
      if (!mounted) {
        dispose = [
          listen_dev(
            span,
            "pointerdown",
            /*pointerdown_handler_1*/
            ctx[32],
            false,
            false,
            false,
            false
          ),
          listen_dev(span, "pointerup", pointerup_handler_1, false, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*all*/
        ctx[6] === "label" || /*rest*/
        ctx[9] === "label"
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_6(ctx);
          if_block.c();
          if_block.m(span, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*orientationStart, percentOf, pipVal*/
      573440 && span_style_value !== (span_style_value = /*orientationStart*/
      ctx[14] + ": " + /*percentOf*/
      ctx[15](
        /*pipVal*/
        ctx[19](
          /*i*/
          ctx[39]
        )
      ) + "%;")) {
        attr_dev(span, "style", span_style_value);
      }
      if (dirty[0] & /*isSelected, pipVal*/
      786432) {
        toggle_class(
          span,
          "selected",
          /*isSelected*/
          ctx[18](
            /*pipVal*/
            ctx[19](
              /*i*/
              ctx[39]
            )
          )
        );
      }
      if (dirty[0] & /*inRange, pipVal*/
      655360) {
        toggle_class(
          span,
          "in-range",
          /*inRange*/
          ctx[17](
            /*pipVal*/
            ctx[19](
              /*i*/
              ctx[39]
            )
          )
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(221:6) {#if pipVal(i) !== min && pipVal(i) !== max}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let span;
  let t_value = (
    /*formatter*/
    ctx[12](
      /*pipVal*/
      ctx[19](
        /*i*/
        ctx[39]
      ),
      /*i*/
      ctx[39],
      /*percentOf*/
      ctx[15](
        /*pipVal*/
        ctx[19](
          /*i*/
          ctx[39]
        )
      )
    ) + ""
  );
  let t;
  let if_block0 = (
    /*prefix*/
    ctx[10] && create_if_block_8(ctx)
  );
  let if_block1 = (
    /*suffix*/
    ctx[11] && create_if_block_7(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block0)
        if_block0.c();
      t = text(t_value);
      if (if_block1)
        if_block1.c();
      attr_dev(span, "class", "pipVal");
      add_location(span, file, 230, 12, 6425);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (if_block0)
        if_block0.m(span, null);
      append_dev(span, t);
      if (if_block1)
        if_block1.m(span, null);
    },
    p: function update(ctx2, dirty) {
      if (
        /*prefix*/
        ctx2[10]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          if_block0.m(span, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & /*formatter, pipVal, percentOf*/
      561152 && t_value !== (t_value = /*formatter*/
      ctx2[12](
        /*pipVal*/
        ctx2[19](
          /*i*/
          ctx2[39]
        ),
        /*i*/
        ctx2[39],
        /*percentOf*/
        ctx2[15](
          /*pipVal*/
          ctx2[19](
            /*i*/
            ctx2[39]
          )
        )
      ) + ""))
        set_data_dev(t, t_value);
      if (
        /*suffix*/
        ctx2[11]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_7(ctx2);
          if_block1.c();
          if_block1.m(span, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(230:10) {#if all === 'label' || rest === 'label'}",
    ctx
  });
  return block;
}
function create_if_block_8(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*prefix*/
        ctx[10]
      );
      attr_dev(span, "class", "pipVal-prefix");
      add_location(span, file, 231, 26, 6473);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*prefix*/
      1024)
        set_data_dev(
          t,
          /*prefix*/
          ctx2[10]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(232:14) {#if prefix}",
    ctx
  });
  return block;
}
function create_if_block_7(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*suffix*/
        ctx[11]
      );
      attr_dev(span, "class", "pipVal-suffix");
      add_location(span, file, 231, 131, 6578);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*suffix*/
      2048)
        set_data_dev(
          t,
          /*suffix*/
          ctx2[11]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(232:119) {#if suffix}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let show_if = (
    /*pipVal*/
    ctx[19](
      /*i*/
      ctx[39]
    ) !== /*min*/
    ctx[0] && /*pipVal*/
    ctx[19](
      /*i*/
      ctx[39]
    ) !== /*max*/
    ctx[1]
  );
  let if_block_anchor;
  let if_block = show_if && create_if_block_5(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*pipVal, min, max*/
      524291)
        show_if = /*pipVal*/
        ctx2[19](
          /*i*/
          ctx2[39]
        ) !== /*min*/
        ctx2[0] && /*pipVal*/
        ctx2[19](
          /*i*/
          ctx2[39]
        ) !== /*max*/
        ctx2[1];
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_5(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(220:4) {#each Array(pipCount + 1) as _, i}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let span;
  let span_style_value;
  let mounted;
  let dispose;
  let if_block = (
    /*all*/
    (ctx[6] === "label" || /*last*/
    ctx[8] === "label") && create_if_block_1(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block)
        if_block.c();
      attr_dev(span, "class", "pip last");
      attr_dev(span, "style", span_style_value = /*orientationStart*/
      ctx[14] + ": 100%;");
      toggle_class(
        span,
        "selected",
        /*isSelected*/
        ctx[18](
          /*max*/
          ctx[1]
        )
      );
      toggle_class(
        span,
        "in-range",
        /*inRange*/
        ctx[17](
          /*max*/
          ctx[1]
        )
      );
      add_location(span, file, 240, 4, 6758);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (if_block)
        if_block.m(span, null);
      if (!mounted) {
        dispose = [
          listen_dev(
            span,
            "pointerdown",
            /*pointerdown_handler_2*/
            ctx[34],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            span,
            "pointerup",
            /*pointerup_handler_2*/
            ctx[35],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*all*/
        ctx2[6] === "label" || /*last*/
        ctx2[8] === "label"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*orientationStart*/
      16384 && span_style_value !== (span_style_value = /*orientationStart*/
      ctx2[14] + ": 100%;")) {
        attr_dev(span, "style", span_style_value);
      }
      if (dirty[0] & /*isSelected, max*/
      262146) {
        toggle_class(
          span,
          "selected",
          /*isSelected*/
          ctx2[18](
            /*max*/
            ctx2[1]
          )
        );
      }
      if (dirty[0] & /*inRange, max*/
      131074) {
        toggle_class(
          span,
          "in-range",
          /*inRange*/
          ctx2[17](
            /*max*/
            ctx2[1]
          )
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(240:2) {#if ( all && last !== false ) || last}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let span;
  let t_value = (
    /*formatter*/
    ctx[12](
      /*fixFloat*/
      ctx[16](
        /*max*/
        ctx[1]
      ),
      /*pipCount*/
      ctx[20],
      100
    ) + ""
  );
  let t;
  let if_block0 = (
    /*prefix*/
    ctx[10] && create_if_block_3(ctx)
  );
  let if_block1 = (
    /*suffix*/
    ctx[11] && create_if_block_2(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block0)
        if_block0.c();
      t = text(t_value);
      if (if_block1)
        if_block1.c();
      attr_dev(span, "class", "pipVal");
      add_location(span, file, 249, 8, 7058);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (if_block0)
        if_block0.m(span, null);
      append_dev(span, t);
      if (if_block1)
        if_block1.m(span, null);
    },
    p: function update(ctx2, dirty) {
      if (
        /*prefix*/
        ctx2[10]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          if_block0.m(span, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & /*formatter, fixFloat, max, pipCount*/
      1118210 && t_value !== (t_value = /*formatter*/
      ctx2[12](
        /*fixFloat*/
        ctx2[16](
          /*max*/
          ctx2[1]
        ),
        /*pipCount*/
        ctx2[20],
        100
      ) + ""))
        set_data_dev(t, t_value);
      if (
        /*suffix*/
        ctx2[11]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          if_block1.m(span, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(249:6) {#if all === 'label' || last === 'label'}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*prefix*/
        ctx[10]
      );
      attr_dev(span, "class", "pipVal-prefix");
      add_location(span, file, 250, 22, 7102);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*prefix*/
      1024)
        set_data_dev(
          t,
          /*prefix*/
          ctx2[10]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(251:10) {#if prefix}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*suffix*/
        ctx[11]
      );
      attr_dev(span, "class", "pipVal-suffix");
      add_location(span, file, 250, 121, 7201);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*suffix*/
      2048)
        set_data_dev(
          t,
          /*suffix*/
          ctx2[11]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(251:109) {#if suffix}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div;
  let t0;
  let t1;
  let if_block0 = (
    /*all*/
    (ctx[6] && /*first*/
    ctx[7] !== false || /*first*/
    ctx[7]) && create_if_block_9(ctx)
  );
  let if_block1 = (
    /*all*/
    (ctx[6] && /*rest*/
    ctx[9] !== false || /*rest*/
    ctx[9]) && create_if_block_4(ctx)
  );
  let if_block2 = (
    /*all*/
    (ctx[6] && /*last*/
    ctx[8] !== false || /*last*/
    ctx[8]) && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      attr_dev(div, "class", "rangePips");
      toggle_class(
        div,
        "disabled",
        /*disabled*/
        ctx[5]
      );
      toggle_class(
        div,
        "hoverable",
        /*hoverable*/
        ctx[4]
      );
      toggle_class(
        div,
        "vertical",
        /*vertical*/
        ctx[2]
      );
      toggle_class(
        div,
        "reversed",
        /*reversed*/
        ctx[3]
      );
      toggle_class(
        div,
        "focus",
        /*focus*/
        ctx[13]
      );
      add_location(div, file, 193, 0, 5227);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t1);
      if (if_block2)
        if_block2.m(div, null);
    },
    p: function update(ctx2, dirty) {
      if (
        /*all*/
        ctx2[6] && /*first*/
        ctx2[7] !== false || /*first*/
        ctx2[7]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_9(ctx2);
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*all*/
        ctx2[6] && /*rest*/
        ctx2[9] !== false || /*rest*/
        ctx2[9]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_4(ctx2);
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*all*/
        ctx2[6] && /*last*/
        ctx2[8] !== false || /*last*/
        ctx2[8]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block(ctx2);
          if_block2.c();
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (dirty[0] & /*disabled*/
      32) {
        toggle_class(
          div,
          "disabled",
          /*disabled*/
          ctx2[5]
        );
      }
      if (dirty[0] & /*hoverable*/
      16) {
        toggle_class(
          div,
          "hoverable",
          /*hoverable*/
          ctx2[4]
        );
      }
      if (dirty[0] & /*vertical*/
      4) {
        toggle_class(
          div,
          "vertical",
          /*vertical*/
          ctx2[2]
        );
      }
      if (dirty[0] & /*reversed*/
      8) {
        toggle_class(
          div,
          "reversed",
          /*reversed*/
          ctx2[3]
        );
      }
      if (dirty[0] & /*focus*/
      8192) {
        toggle_class(
          div,
          "focus",
          /*focus*/
          ctx2[13]
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let pipStep;
  let pipCount;
  let pipVal;
  let isSelected;
  let inRange;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RangePips", slots, []);
  let { range = false } = $$props;
  let { min = 0 } = $$props;
  let { max = 100 } = $$props;
  let { step = 1 } = $$props;
  let { values = [(max + min) / 2] } = $$props;
  let { vertical = false } = $$props;
  let { reversed = false } = $$props;
  let { hoverable = true } = $$props;
  let { disabled = false } = $$props;
  let { pipstep = void 0 } = $$props;
  let { all = true } = $$props;
  let { first = void 0 } = $$props;
  let { last = void 0 } = $$props;
  let { rest = void 0 } = $$props;
  let { prefix = "" } = $$props;
  let { suffix = "" } = $$props;
  let { formatter = (v, i) => v } = $$props;
  let { focus = void 0 } = $$props;
  let { orientationStart = void 0 } = $$props;
  let { percentOf = void 0 } = $$props;
  let { moveHandle = void 0 } = $$props;
  let { fixFloat = void 0 } = $$props;
  let { normalisedClient: normalisedClient2 = void 0 } = $$props;
  let clientStart;
  function labelDown(e) {
    e = normalisedClient2(e);
    clientStart = { x: e.clientX, y: e.clientY };
  }
  function labelUp(val, e) {
    e = normalisedClient2(e);
    if (!disabled) {
      const distanceMoved = Math.sqrt(Math.pow(clientStart.x - e.clientX, 2) + Math.pow(clientStart.y - e.clientY, 2));
      if (clientStart && distanceMoved <= 5) {
        moveHandle(void 0, val);
      }
    }
  }
  const writable_props = [
    "range",
    "min",
    "max",
    "step",
    "values",
    "vertical",
    "reversed",
    "hoverable",
    "disabled",
    "pipstep",
    "all",
    "first",
    "last",
    "rest",
    "prefix",
    "suffix",
    "formatter",
    "focus",
    "orientationStart",
    "percentOf",
    "moveHandle",
    "fixFloat",
    "normalisedClient"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<RangePips> was created with unknown prop '${key}'`);
  });
  const pointerdown_handler = (e) => {
    labelDown(e);
  };
  const pointerup_handler = (e) => {
    labelUp(pipVal(min), e);
  };
  const pointerdown_handler_1 = (e) => {
    labelDown(e);
  };
  const pointerup_handler_1 = (i, e) => {
    labelUp(pipVal(i), e);
  };
  const pointerdown_handler_2 = (e) => {
    labelDown(e);
  };
  const pointerup_handler_2 = (e) => {
    labelUp(pipVal(max), e);
  };
  $$self.$$set = ($$props2) => {
    if ("range" in $$props2)
      $$invalidate(23, range = $$props2.range);
    if ("min" in $$props2)
      $$invalidate(0, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(1, max = $$props2.max);
    if ("step" in $$props2)
      $$invalidate(24, step = $$props2.step);
    if ("values" in $$props2)
      $$invalidate(25, values = $$props2.values);
    if ("vertical" in $$props2)
      $$invalidate(2, vertical = $$props2.vertical);
    if ("reversed" in $$props2)
      $$invalidate(3, reversed = $$props2.reversed);
    if ("hoverable" in $$props2)
      $$invalidate(4, hoverable = $$props2.hoverable);
    if ("disabled" in $$props2)
      $$invalidate(5, disabled = $$props2.disabled);
    if ("pipstep" in $$props2)
      $$invalidate(26, pipstep = $$props2.pipstep);
    if ("all" in $$props2)
      $$invalidate(6, all = $$props2.all);
    if ("first" in $$props2)
      $$invalidate(7, first = $$props2.first);
    if ("last" in $$props2)
      $$invalidate(8, last = $$props2.last);
    if ("rest" in $$props2)
      $$invalidate(9, rest = $$props2.rest);
    if ("prefix" in $$props2)
      $$invalidate(10, prefix = $$props2.prefix);
    if ("suffix" in $$props2)
      $$invalidate(11, suffix = $$props2.suffix);
    if ("formatter" in $$props2)
      $$invalidate(12, formatter = $$props2.formatter);
    if ("focus" in $$props2)
      $$invalidate(13, focus = $$props2.focus);
    if ("orientationStart" in $$props2)
      $$invalidate(14, orientationStart = $$props2.orientationStart);
    if ("percentOf" in $$props2)
      $$invalidate(15, percentOf = $$props2.percentOf);
    if ("moveHandle" in $$props2)
      $$invalidate(27, moveHandle = $$props2.moveHandle);
    if ("fixFloat" in $$props2)
      $$invalidate(16, fixFloat = $$props2.fixFloat);
    if ("normalisedClient" in $$props2)
      $$invalidate(28, normalisedClient2 = $$props2.normalisedClient);
  };
  $$self.$capture_state = () => ({
    range,
    min,
    max,
    step,
    values,
    vertical,
    reversed,
    hoverable,
    disabled,
    pipstep,
    all,
    first,
    last,
    rest,
    prefix,
    suffix,
    formatter,
    focus,
    orientationStart,
    percentOf,
    moveHandle,
    fixFloat,
    normalisedClient: normalisedClient2,
    clientStart,
    labelDown,
    labelUp,
    inRange,
    isSelected,
    pipStep,
    pipVal,
    pipCount
  });
  $$self.$inject_state = ($$props2) => {
    if ("range" in $$props2)
      $$invalidate(23, range = $$props2.range);
    if ("min" in $$props2)
      $$invalidate(0, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(1, max = $$props2.max);
    if ("step" in $$props2)
      $$invalidate(24, step = $$props2.step);
    if ("values" in $$props2)
      $$invalidate(25, values = $$props2.values);
    if ("vertical" in $$props2)
      $$invalidate(2, vertical = $$props2.vertical);
    if ("reversed" in $$props2)
      $$invalidate(3, reversed = $$props2.reversed);
    if ("hoverable" in $$props2)
      $$invalidate(4, hoverable = $$props2.hoverable);
    if ("disabled" in $$props2)
      $$invalidate(5, disabled = $$props2.disabled);
    if ("pipstep" in $$props2)
      $$invalidate(26, pipstep = $$props2.pipstep);
    if ("all" in $$props2)
      $$invalidate(6, all = $$props2.all);
    if ("first" in $$props2)
      $$invalidate(7, first = $$props2.first);
    if ("last" in $$props2)
      $$invalidate(8, last = $$props2.last);
    if ("rest" in $$props2)
      $$invalidate(9, rest = $$props2.rest);
    if ("prefix" in $$props2)
      $$invalidate(10, prefix = $$props2.prefix);
    if ("suffix" in $$props2)
      $$invalidate(11, suffix = $$props2.suffix);
    if ("formatter" in $$props2)
      $$invalidate(12, formatter = $$props2.formatter);
    if ("focus" in $$props2)
      $$invalidate(13, focus = $$props2.focus);
    if ("orientationStart" in $$props2)
      $$invalidate(14, orientationStart = $$props2.orientationStart);
    if ("percentOf" in $$props2)
      $$invalidate(15, percentOf = $$props2.percentOf);
    if ("moveHandle" in $$props2)
      $$invalidate(27, moveHandle = $$props2.moveHandle);
    if ("fixFloat" in $$props2)
      $$invalidate(16, fixFloat = $$props2.fixFloat);
    if ("normalisedClient" in $$props2)
      $$invalidate(28, normalisedClient2 = $$props2.normalisedClient);
    if ("clientStart" in $$props2)
      clientStart = $$props2.clientStart;
    if ("inRange" in $$props2)
      $$invalidate(17, inRange = $$props2.inRange);
    if ("isSelected" in $$props2)
      $$invalidate(18, isSelected = $$props2.isSelected);
    if ("pipStep" in $$props2)
      $$invalidate(29, pipStep = $$props2.pipStep);
    if ("pipVal" in $$props2)
      $$invalidate(19, pipVal = $$props2.pipVal);
    if ("pipCount" in $$props2)
      $$invalidate(20, pipCount = $$props2.pipCount);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*pipstep, max, min, step, vertical*/
    83886087) {
      $:
        $$invalidate(29, pipStep = pipstep || ((max - min) / step >= (vertical ? 50 : 100) ? (max - min) / (vertical ? 10 : 20) : 1));
    }
    if ($$self.$$.dirty[0] & /*max, min, step, pipStep*/
    553648131) {
      $:
        $$invalidate(20, pipCount = parseInt((max - min) / (step * pipStep), 10));
    }
    if ($$self.$$.dirty[0] & /*fixFloat, min, step, pipStep*/
    553713665) {
      $:
        $$invalidate(19, pipVal = function(val) {
          return fixFloat(min + val * step * pipStep);
        });
    }
    if ($$self.$$.dirty[0] & /*values, fixFloat*/
    33619968) {
      $:
        $$invalidate(18, isSelected = function(val) {
          return values.some((v) => fixFloat(v) === fixFloat(val));
        });
    }
    if ($$self.$$.dirty[0] & /*range, values*/
    41943040) {
      $:
        $$invalidate(17, inRange = function(val) {
          if (range === "min") {
            return values[0] > val;
          } else if (range === "max") {
            return values[0] < val;
          } else if (range) {
            return values[0] < val && values[1] > val;
          }
        });
    }
  };
  return [
    min,
    max,
    vertical,
    reversed,
    hoverable,
    disabled,
    all,
    first,
    last,
    rest,
    prefix,
    suffix,
    formatter,
    focus,
    orientationStart,
    percentOf,
    fixFloat,
    inRange,
    isSelected,
    pipVal,
    pipCount,
    labelDown,
    labelUp,
    range,
    step,
    values,
    pipstep,
    moveHandle,
    normalisedClient2,
    pipStep,
    pointerdown_handler,
    pointerup_handler,
    pointerdown_handler_1,
    pointerup_handler_1,
    pointerdown_handler_2,
    pointerup_handler_2
  ];
}
var RangePips = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        range: 23,
        min: 0,
        max: 1,
        step: 24,
        values: 25,
        vertical: 2,
        reversed: 3,
        hoverable: 4,
        disabled: 5,
        pipstep: 26,
        all: 6,
        first: 7,
        last: 8,
        rest: 9,
        prefix: 10,
        suffix: 11,
        formatter: 12,
        focus: 13,
        orientationStart: 14,
        percentOf: 15,
        moveHandle: 27,
        fixFloat: 16,
        normalisedClient: 28
      },
      add_css,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RangePips",
      options,
      id: create_fragment.name
    });
  }
  get range() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set range(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get values() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set values(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reversed() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reversed(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hoverable() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hoverable(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pipstep() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pipstep(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get all() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set all(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get first() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set first(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get last() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set last(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rest() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rest(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get prefix() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set prefix(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get suffix() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set suffix(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatter() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatter(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set focus(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get orientationStart() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set orientationStart(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get percentOf() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set percentOf(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get moveHandle() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set moveHandle(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fixFloat() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fixFloat(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get normalisedClient() {
    throw new Error("<RangePips>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set normalisedClient(value) {
    throw new Error("<RangePips>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RangePips_default = RangePips;

// node_modules/svelte-range-slider-pips/src/RangeSlider.svelte
var { console: console_1 } = globals;
var file2 = "node_modules/svelte-range-slider-pips/src/RangeSlider.svelte";
function add_css2(target) {
  append_styles(target, "svelte-ryi37q", '.rangeSlider{--slider:var(--range-slider, #d7dada);--handle-inactive:var(--range-handle-inactive, #99a2a2);--handle:var(--range-handle, #838de7);--handle-focus:var(--range-handle-focus, #4a40d4);--handle-border:var(--range-handle-border, var(--handle));--range-inactive:var(--range-range-inactive, var(--handle-inactive));--range:var(--range-range, var(--handle-focus));--float-inactive:var(--range-float-inactive, var(--handle-inactive));--float:var(--range-float, var(--handle-focus));--float-text:var(--range-float-text, white)}.rangeSlider{position:relative;border-radius:100px;height:0.5em;margin:1em;transition:opacity 0.2s ease;user-select:none}.rangeSlider *{user-select:none}.rangeSlider.pips{margin-bottom:1.8em}.rangeSlider.pip-labels{margin-bottom:2.8em}.rangeSlider.vertical{display:inline-block;border-radius:100px;width:0.5em;min-height:200px}.rangeSlider.vertical.pips{margin-right:1.8em;margin-bottom:1em}.rangeSlider.vertical.pip-labels{margin-right:2.8em;margin-bottom:1em}.rangeSlider .rangeHandle{position:absolute;display:block;height:1.4em;width:1.4em;top:0.25em;bottom:auto;transform:translateY(-50%) translateX(-50%);z-index:2}.rangeSlider.reversed .rangeHandle{transform:translateY(-50%) translateX(50%)}.rangeSlider.vertical .rangeHandle{left:0.25em;top:auto;transform:translateY(50%) translateX(-50%)}.rangeSlider.vertical.reversed .rangeHandle{transform:translateY(-50%) translateX(-50%)}.rangeSlider .rangeNub,.rangeSlider .rangeHandle:before{position:absolute;left:0;top:0;display:block;border-radius:10em;height:100%;width:100%;transition:box-shadow 0.2s ease}.rangeSlider .rangeHandle:before{content:"";left:1px;top:1px;bottom:1px;right:1px;height:auto;width:auto;box-shadow:0 0 0 0px var(--handle-border);opacity:0}.rangeSlider.hoverable:not(.disabled) .rangeHandle:hover:before{box-shadow:0 0 0 8px var(--handle-border);opacity:0.2}.rangeSlider.hoverable:not(.disabled) .rangeHandle.press:before,.rangeSlider.hoverable:not(.disabled) .rangeHandle.press:hover:before{box-shadow:0 0 0 12px var(--handle-border);opacity:0.4}.rangeSlider.range:not(.min):not(.max) .rangeNub{border-radius:10em 10em 10em 1.6em}.rangeSlider.range .rangeHandle:nth-of-type(1) .rangeNub{transform:rotate(-135deg)}.rangeSlider.range .rangeHandle:nth-of-type(2) .rangeNub{transform:rotate(45deg)}.rangeSlider.range.reversed .rangeHandle:nth-of-type(1) .rangeNub{transform:rotate(45deg)}.rangeSlider.range.reversed .rangeHandle:nth-of-type(2) .rangeNub{transform:rotate(-135deg)}.rangeSlider.range.vertical .rangeHandle:nth-of-type(1) .rangeNub{transform:rotate(135deg)}.rangeSlider.range.vertical .rangeHandle:nth-of-type(2) .rangeNub{transform:rotate(-45deg)}.rangeSlider.range.vertical.reversed .rangeHandle:nth-of-type(1) .rangeNub{transform:rotate(-45deg)}.rangeSlider.range.vertical.reversed .rangeHandle:nth-of-type(2) .rangeNub{transform:rotate(135deg)}.rangeSlider .rangeFloat{display:block;position:absolute;left:50%;top:-0.5em;transform:translate(-50%, -100%);font-size:1em;text-align:center;opacity:0;pointer-events:none;white-space:nowrap;transition:all 0.2s ease;font-size:0.9em;padding:0.2em 0.4em;border-radius:0.2em}.rangeSlider .rangeHandle.active .rangeFloat,.rangeSlider.hoverable .rangeHandle:hover .rangeFloat{opacity:1;top:-0.2em;transform:translate(-50%, -100%)}.rangeSlider .rangeBar{position:absolute;display:block;transition:background 0.2s ease;border-radius:1em;height:0.5em;top:0;user-select:none;z-index:1}.rangeSlider.vertical .rangeBar{width:0.5em;height:auto}.rangeSlider{background-color:#d7dada;background-color:var(--slider)}.rangeSlider .rangeBar{background-color:#99a2a2;background-color:var(--range-inactive)}.rangeSlider.focus .rangeBar{background-color:#838de7;background-color:var(--range)}.rangeSlider .rangeNub{background-color:#99a2a2;background-color:var(--handle-inactive)}.rangeSlider.focus .rangeNub{background-color:#838de7;background-color:var(--handle)}.rangeSlider .rangeHandle.active .rangeNub{background-color:#4a40d4;background-color:var(--handle-focus)}.rangeSlider .rangeFloat{color:white;color:var(--float-text);background-color:#99a2a2;background-color:var(--float-inactive)}.rangeSlider.focus .rangeFloat{background-color:#4a40d4;background-color:var(--float)}.rangeSlider.disabled{opacity:0.5}.rangeSlider.disabled .rangeNub{background-color:#d7dada;background-color:var(--slider)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBRSxNQUFNLENBQ1gsU0FBUyxDQUFFLFVBQVUsSUFBSSxDQUFDLENBQUMsS0FBSyxDQUNsQyxDQUNRLHNCQUF3QixDQUM5QixRQUFRLENBQUUsUUFBUSxDQUNsQixPQUFPLENBQUUsS0FBSyxDQUNkLFVBQVUsQ0FBRSxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FDaEMsYUFBYSxDQUFFLEdBQUcsQ0FDbEIsTUFBTSxDQUFFLEtBQUssQ0FDYixHQUFHLENBQUUsQ0FBQyxDQUNOLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLE9BQU8sQ0FBRSxDQUNYLENBQ1EsK0JBQWlDLENBQ3ZDLEtBQUssQ0FBRSxLQUFLLENBQ1osTUFBTSxDQUFFLElBQ1YsQ0FDUSxZQUFjLENBQ3BCLGdCQUFnQixDQUFFLE9BQU8sQ0FDekIsZ0JBQWdCLENBQUUsSUFBSSxRQUFRLENBQ2hDLENBQ1Esc0JBQXdCLENBQzlCLGdCQUFnQixDQUFFLE9BQU8sQ0FDekIsZ0JBQWdCLENBQUUsSUFBSSxnQkFBZ0IsQ0FDeEMsQ0FDUSw0QkFBOEIsQ0FDcEMsZ0JBQWdCLENBQUUsT0FBTyxDQUN6QixnQkFBZ0IsQ0FBRSxJQUFJLE9BQU8sQ0FDL0IsQ0FDUSxzQkFBd0IsQ0FDOUIsZ0JBQWdCLENBQUUsT0FBTyxDQUN6QixnQkFBZ0IsQ0FBRSxJQUFJLGlCQUFpQixDQUN6QyxDQUNRLDRCQUE4QixDQUNwQyxnQkFBZ0IsQ0FBRSxPQUFPLENBQ3pCLGdCQUFnQixDQUFFLElBQUksUUFBUSxDQUNoQyxDQUNRLDBDQUE0QyxDQUNsRCxnQkFBZ0IsQ0FBRSxPQUFPLENBQ3pCLGdCQUFnQixDQUFFLElBQUksY0FBYyxDQUN0QyxDQUNRLHdCQUEwQixDQUNoQyxLQUFLLENBQUUsS0FBSyxDQUNaLEtBQUssQ0FBRSxJQUFJLFlBQVksQ0FBQyxDQUN4QixnQkFBZ0IsQ0FBRSxPQUFPLENBQ3pCLGdCQUFnQixDQUFFLElBQUksZ0JBQWdCLENBQ3hDLENBQ1EsOEJBQWdDLENBQ3RDLGdCQUFnQixDQUFFLE9BQU8sQ0FDekIsZ0JBQWdCLENBQUUsSUFBSSxPQUFPLENBQy9CLENBQ1EscUJBQXVCLENBQzdCLE9BQU8sQ0FBRSxHQUNYLENBQ1EsK0JBQWlDLENBQ3ZDLGdCQUFnQixDQUFFLE9BQU8sQ0FDekIsZ0JBQWdCLENBQUUsSUFBSSxRQUFRLENBQ2hDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIlJhbmdlU2xpZGVyLnN2ZWx0ZSJdfQ== */');
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[65] = list[i];
  child_ctx[67] = i;
  return child_ctx;
}
function create_if_block_22(ctx) {
  let span;
  let t_value = (
    /*handleFormatter*/
    ctx[21](
      /*value*/
      ctx[65],
      /*index*/
      ctx[67],
      /*percentOf*/
      ctx[24](
        /*value*/
        ctx[65]
      )
    ) + ""
  );
  let t;
  let if_block0 = (
    /*prefix*/
    ctx[18] && create_if_block_42(ctx)
  );
  let if_block1 = (
    /*suffix*/
    ctx[19] && create_if_block_32(ctx)
  );
  const block = {
    c: function create() {
      span = element("span");
      if (if_block0)
        if_block0.c();
      t = text(t_value);
      if (if_block1)
        if_block1.c();
      attr_dev(span, "class", "rangeFloat");
      add_location(span, file2, 842, 8, 25193);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      if (if_block0)
        if_block0.m(span, null);
      append_dev(span, t);
      if (if_block1)
        if_block1.m(span, null);
    },
    p: function update(ctx2, dirty) {
      if (
        /*prefix*/
        ctx2[18]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_42(ctx2);
          if_block0.c();
          if_block0.m(span, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & /*handleFormatter, values, percentOf*/
      18874369 && t_value !== (t_value = /*handleFormatter*/
      ctx2[21](
        /*value*/
        ctx2[65],
        /*index*/
        ctx2[67],
        /*percentOf*/
        ctx2[24](
          /*value*/
          ctx2[65]
        )
      ) + ""))
        set_data_dev(t, t_value);
      if (
        /*suffix*/
        ctx2[19]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_32(ctx2);
          if_block1.c();
          if_block1.m(span, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(842:6) {#if float}",
    ctx
  });
  return block;
}
function create_if_block_42(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*prefix*/
        ctx[18]
      );
      attr_dev(span, "class", "rangeFloat-prefix");
      add_location(span, file2, 843, 22, 25241);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*prefix*/
      262144)
        set_data_dev(
          t,
          /*prefix*/
          ctx2[18]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_42.name,
    type: "if",
    source: "(844:10) {#if prefix}",
    ctx
  });
  return block;
}
function create_if_block_32(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(
        /*suffix*/
        ctx[19]
      );
      attr_dev(span, "class", "rangeFloat-suffix");
      add_location(span, file2, 843, 133, 25352);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
      append_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*suffix*/
      524288)
        set_data_dev(
          t,
          /*suffix*/
          ctx2[19]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(844:121) {#if suffix}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let span1;
  let span0;
  let t;
  let span1_data_handle_value;
  let span1_style_value;
  let span1_aria_label_value;
  let span1_aria_valuemin_value;
  let span1_aria_valuemax_value;
  let span1_aria_valuenow_value;
  let span1_aria_valuetext_value;
  let span1_aria_orientation_value;
  let span1_tabindex_value;
  let mounted;
  let dispose;
  let if_block = (
    /*float*/
    ctx[7] && create_if_block_22(ctx)
  );
  const block = {
    c: function create() {
      span1 = element("span");
      span0 = element("span");
      t = space();
      if (if_block)
        if_block.c();
      attr_dev(span0, "class", "rangeNub");
      add_location(span0, file2, 840, 6, 25141);
      attr_dev(span1, "role", "slider");
      attr_dev(span1, "class", "rangeHandle");
      attr_dev(span1, "data-handle", span1_data_handle_value = /*index*/
      ctx[67]);
      attr_dev(span1, "style", span1_style_value = /*orientationStart*/
      ctx[29] + ": " + /*$springPositions*/
      ctx[30][
        /*index*/
        ctx[67]
      ] + "%; z-index: " + /*activeHandle*/
      (ctx[27] === /*index*/
      ctx[67] ? 3 : 2) + ";");
      attr_dev(span1, "aria-label", span1_aria_label_value = /*ariaLabels*/
      ctx[22][
        /*index*/
        ctx[67]
      ]);
      attr_dev(span1, "aria-valuemin", span1_aria_valuemin_value = /*range*/
      ctx[2] === true && /*index*/
      ctx[67] === 1 ? (
        /*values*/
        ctx[0][0]
      ) : (
        /*min*/
        ctx[3]
      ));
      attr_dev(span1, "aria-valuemax", span1_aria_valuemax_value = /*range*/
      ctx[2] === true && /*index*/
      ctx[67] === 0 ? (
        /*values*/
        ctx[0][1]
      ) : (
        /*max*/
        ctx[4]
      ));
      attr_dev(span1, "aria-valuenow", span1_aria_valuenow_value = /*value*/
      ctx[65]);
      attr_dev(span1, "aria-valuetext", span1_aria_valuetext_value = "" + /*prefix*/
      (ctx[18] + /*handleFormatter*/
      ctx[21](
        /*value*/
        ctx[65],
        /*index*/
        ctx[67],
        /*percentOf*/
        ctx[24](
          /*value*/
          ctx[65]
        )
      ) + /*suffix*/
      ctx[19]));
      attr_dev(span1, "aria-orientation", span1_aria_orientation_value = /*vertical*/
      ctx[6] ? "vertical" : "horizontal");
      attr_dev(
        span1,
        "aria-disabled",
        /*disabled*/
        ctx[10]
      );
      attr_dev(
        span1,
        "disabled",
        /*disabled*/
        ctx[10]
      );
      attr_dev(span1, "tabindex", span1_tabindex_value = /*disabled*/
      ctx[10] ? -1 : 0);
      toggle_class(
        span1,
        "active",
        /*focus*/
        ctx[25] && /*activeHandle*/
        ctx[27] === /*index*/
        ctx[67]
      );
      toggle_class(
        span1,
        "press",
        /*handlePressed*/
        ctx[26] && /*activeHandle*/
        ctx[27] === /*index*/
        ctx[67]
      );
      add_location(span1, file2, 820, 4, 24291);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span1, anchor);
      append_dev(span1, span0);
      append_dev(span1, t);
      if (if_block)
        if_block.m(span1, null);
      if (!mounted) {
        dispose = [
          listen_dev(
            span1,
            "blur",
            /*sliderBlurHandle*/
            ctx[35],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            span1,
            "focus",
            /*sliderFocusHandle*/
            ctx[36],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            span1,
            "keydown",
            /*sliderKeydown*/
            ctx[37],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*float*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_22(ctx2);
          if_block.c();
          if_block.m(span1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*orientationStart, $springPositions, activeHandle*/
      1744830464 && span1_style_value !== (span1_style_value = /*orientationStart*/
      ctx2[29] + ": " + /*$springPositions*/
      ctx2[30][
        /*index*/
        ctx2[67]
      ] + "%; z-index: " + /*activeHandle*/
      (ctx2[27] === /*index*/
      ctx2[67] ? 3 : 2) + ";")) {
        attr_dev(span1, "style", span1_style_value);
      }
      if (dirty[0] & /*ariaLabels*/
      4194304 && span1_aria_label_value !== (span1_aria_label_value = /*ariaLabels*/
      ctx2[22][
        /*index*/
        ctx2[67]
      ])) {
        attr_dev(span1, "aria-label", span1_aria_label_value);
      }
      if (dirty[0] & /*range, values, min*/
      13 && span1_aria_valuemin_value !== (span1_aria_valuemin_value = /*range*/
      ctx2[2] === true && /*index*/
      ctx2[67] === 1 ? (
        /*values*/
        ctx2[0][0]
      ) : (
        /*min*/
        ctx2[3]
      ))) {
        attr_dev(span1, "aria-valuemin", span1_aria_valuemin_value);
      }
      if (dirty[0] & /*range, values, max*/
      21 && span1_aria_valuemax_value !== (span1_aria_valuemax_value = /*range*/
      ctx2[2] === true && /*index*/
      ctx2[67] === 0 ? (
        /*values*/
        ctx2[0][1]
      ) : (
        /*max*/
        ctx2[4]
      ))) {
        attr_dev(span1, "aria-valuemax", span1_aria_valuemax_value);
      }
      if (dirty[0] & /*values*/
      1 && span1_aria_valuenow_value !== (span1_aria_valuenow_value = /*value*/
      ctx2[65])) {
        attr_dev(span1, "aria-valuenow", span1_aria_valuenow_value);
      }
      if (dirty[0] & /*prefix, handleFormatter, values, percentOf, suffix*/
      19660801 && span1_aria_valuetext_value !== (span1_aria_valuetext_value = "" + /*prefix*/
      (ctx2[18] + /*handleFormatter*/
      ctx2[21](
        /*value*/
        ctx2[65],
        /*index*/
        ctx2[67],
        /*percentOf*/
        ctx2[24](
          /*value*/
          ctx2[65]
        )
      ) + /*suffix*/
      ctx2[19]))) {
        attr_dev(span1, "aria-valuetext", span1_aria_valuetext_value);
      }
      if (dirty[0] & /*vertical*/
      64 && span1_aria_orientation_value !== (span1_aria_orientation_value = /*vertical*/
      ctx2[6] ? "vertical" : "horizontal")) {
        attr_dev(span1, "aria-orientation", span1_aria_orientation_value);
      }
      if (dirty[0] & /*disabled*/
      1024) {
        attr_dev(
          span1,
          "aria-disabled",
          /*disabled*/
          ctx2[10]
        );
      }
      if (dirty[0] & /*disabled*/
      1024) {
        attr_dev(
          span1,
          "disabled",
          /*disabled*/
          ctx2[10]
        );
      }
      if (dirty[0] & /*disabled*/
      1024 && span1_tabindex_value !== (span1_tabindex_value = /*disabled*/
      ctx2[10] ? -1 : 0)) {
        attr_dev(span1, "tabindex", span1_tabindex_value);
      }
      if (dirty[0] & /*focus, activeHandle*/
      167772160) {
        toggle_class(
          span1,
          "active",
          /*focus*/
          ctx2[25] && /*activeHandle*/
          ctx2[27] === /*index*/
          ctx2[67]
        );
      }
      if (dirty[0] & /*handlePressed, activeHandle*/
      201326592) {
        toggle_class(
          span1,
          "press",
          /*handlePressed*/
          ctx2[26] && /*activeHandle*/
          ctx2[27] === /*index*/
          ctx2[67]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span1);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(820:2) {#each values as value, index}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let span;
  let span_style_value;
  const block = {
    c: function create() {
      span = element("span");
      attr_dev(span, "class", "rangeBar");
      attr_dev(span, "style", span_style_value = /*orientationStart*/
      ctx[29] + ": " + /*rangeStart*/
      ctx[33](
        /*$springPositions*/
        ctx[30]
      ) + "%; " + /*orientationEnd*/
      ctx[28] + ": " + /*rangeEnd*/
      ctx[34](
        /*$springPositions*/
        ctx[30]
      ) + "%;");
      add_location(span, file2, 849, 4, 25473);
    },
    m: function mount(target, anchor) {
      insert_dev(target, span, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*orientationStart, $springPositions, orientationEnd*/
      1879048192 && span_style_value !== (span_style_value = /*orientationStart*/
      ctx2[29] + ": " + /*rangeStart*/
      ctx2[33](
        /*$springPositions*/
        ctx2[30]
      ) + "%; " + /*orientationEnd*/
      ctx2[28] + ": " + /*rangeEnd*/
      ctx2[34](
        /*$springPositions*/
        ctx2[30]
      ) + "%;")) {
        attr_dev(span, "style", span_style_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(849:2) {#if range}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let rangepips;
  let current;
  rangepips = new RangePips_default({
    props: {
      values: (
        /*values*/
        ctx[0]
      ),
      min: (
        /*min*/
        ctx[3]
      ),
      max: (
        /*max*/
        ctx[4]
      ),
      step: (
        /*step*/
        ctx[5]
      ),
      range: (
        /*range*/
        ctx[2]
      ),
      vertical: (
        /*vertical*/
        ctx[6]
      ),
      reversed: (
        /*reversed*/
        ctx[8]
      ),
      orientationStart: (
        /*orientationStart*/
        ctx[29]
      ),
      hoverable: (
        /*hoverable*/
        ctx[9]
      ),
      disabled: (
        /*disabled*/
        ctx[10]
      ),
      all: (
        /*all*/
        ctx[13]
      ),
      first: (
        /*first*/
        ctx[14]
      ),
      last: (
        /*last*/
        ctx[15]
      ),
      rest: (
        /*rest*/
        ctx[16]
      ),
      pipstep: (
        /*pipstep*/
        ctx[12]
      ),
      prefix: (
        /*prefix*/
        ctx[18]
      ),
      suffix: (
        /*suffix*/
        ctx[19]
      ),
      formatter: (
        /*formatter*/
        ctx[20]
      ),
      focus: (
        /*focus*/
        ctx[25]
      ),
      percentOf: (
        /*percentOf*/
        ctx[24]
      ),
      moveHandle: (
        /*moveHandle*/
        ctx[32]
      ),
      fixFloat: (
        /*fixFloat*/
        ctx[31]
      ),
      normalisedClient
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(rangepips.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(rangepips, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const rangepips_changes = {};
      if (dirty[0] & /*values*/
      1)
        rangepips_changes.values = /*values*/
        ctx2[0];
      if (dirty[0] & /*min*/
      8)
        rangepips_changes.min = /*min*/
        ctx2[3];
      if (dirty[0] & /*max*/
      16)
        rangepips_changes.max = /*max*/
        ctx2[4];
      if (dirty[0] & /*step*/
      32)
        rangepips_changes.step = /*step*/
        ctx2[5];
      if (dirty[0] & /*range*/
      4)
        rangepips_changes.range = /*range*/
        ctx2[2];
      if (dirty[0] & /*vertical*/
      64)
        rangepips_changes.vertical = /*vertical*/
        ctx2[6];
      if (dirty[0] & /*reversed*/
      256)
        rangepips_changes.reversed = /*reversed*/
        ctx2[8];
      if (dirty[0] & /*orientationStart*/
      536870912)
        rangepips_changes.orientationStart = /*orientationStart*/
        ctx2[29];
      if (dirty[0] & /*hoverable*/
      512)
        rangepips_changes.hoverable = /*hoverable*/
        ctx2[9];
      if (dirty[0] & /*disabled*/
      1024)
        rangepips_changes.disabled = /*disabled*/
        ctx2[10];
      if (dirty[0] & /*all*/
      8192)
        rangepips_changes.all = /*all*/
        ctx2[13];
      if (dirty[0] & /*first*/
      16384)
        rangepips_changes.first = /*first*/
        ctx2[14];
      if (dirty[0] & /*last*/
      32768)
        rangepips_changes.last = /*last*/
        ctx2[15];
      if (dirty[0] & /*rest*/
      65536)
        rangepips_changes.rest = /*rest*/
        ctx2[16];
      if (dirty[0] & /*pipstep*/
      4096)
        rangepips_changes.pipstep = /*pipstep*/
        ctx2[12];
      if (dirty[0] & /*prefix*/
      262144)
        rangepips_changes.prefix = /*prefix*/
        ctx2[18];
      if (dirty[0] & /*suffix*/
      524288)
        rangepips_changes.suffix = /*suffix*/
        ctx2[19];
      if (dirty[0] & /*formatter*/
      1048576)
        rangepips_changes.formatter = /*formatter*/
        ctx2[20];
      if (dirty[0] & /*focus*/
      33554432)
        rangepips_changes.focus = /*focus*/
        ctx2[25];
      if (dirty[0] & /*percentOf*/
      16777216)
        rangepips_changes.percentOf = /*percentOf*/
        ctx2[24];
      rangepips.$set(rangepips_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rangepips.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rangepips.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(rangepips, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(855:2) {#if pips}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like_dev(
    /*values*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  let if_block0 = (
    /*range*/
    ctx[2] && create_if_block_13(ctx)
  );
  let if_block1 = (
    /*pips*/
    ctx[11] && create_if_block2(ctx)
  );
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      attr_dev(
        div,
        "id",
        /*id*/
        ctx[17]
      );
      attr_dev(div, "class", "rangeSlider");
      toggle_class(
        div,
        "range",
        /*range*/
        ctx[2]
      );
      toggle_class(
        div,
        "disabled",
        /*disabled*/
        ctx[10]
      );
      toggle_class(
        div,
        "hoverable",
        /*hoverable*/
        ctx[9]
      );
      toggle_class(
        div,
        "vertical",
        /*vertical*/
        ctx[6]
      );
      toggle_class(
        div,
        "reversed",
        /*reversed*/
        ctx[8]
      );
      toggle_class(
        div,
        "focus",
        /*focus*/
        ctx[25]
      );
      toggle_class(
        div,
        "min",
        /*range*/
        ctx[2] === "min"
      );
      toggle_class(
        div,
        "max",
        /*range*/
        ctx[2] === "max"
      );
      toggle_class(
        div,
        "pips",
        /*pips*/
        ctx[11]
      );
      toggle_class(
        div,
        "pip-labels",
        /*all*/
        ctx[13] === "label" || /*first*/
        ctx[14] === "label" || /*last*/
        ctx[15] === "label" || /*rest*/
        ctx[16] === "label"
      );
      add_location(div, file2, 800, 0, 23757);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append_dev(div, t0);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t1);
      if (if_block1)
        if_block1.m(div, null);
      ctx[51](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "mousedown",
            /*bodyInteractStart*/
            ctx[40],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "touchstart",
            /*bodyInteractStart*/
            ctx[40],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "mousemove",
            /*bodyInteract*/
            ctx[41],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "touchmove",
            /*bodyInteract*/
            ctx[41],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "mouseup",
            /*bodyMouseUp*/
            ctx[42],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "touchend",
            /*bodyTouchEnd*/
            ctx[43],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            window,
            "keydown",
            /*bodyKeyDown*/
            ctx[44],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mousedown",
            /*sliderInteractStart*/
            ctx[38],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "mouseup",
            /*sliderInteractEnd*/
            ctx[39],
            false,
            false,
            false,
            false
          ),
          listen_dev(div, "touchstart", prevent_default(
            /*sliderInteractStart*/
            ctx[38]
          ), false, true, false, false),
          listen_dev(div, "touchend", prevent_default(
            /*sliderInteractEnd*/
            ctx[39]
          ), false, true, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*orientationStart, $springPositions, activeHandle, ariaLabels, range, values, min, max, prefix, handleFormatter, percentOf, suffix, vertical, disabled, focus, handlePressed, float*/
      1869350109 | dirty[1] & /*sliderBlurHandle, sliderFocusHandle, sliderKeydown*/
      112) {
        each_value = ensure_array_like_dev(
          /*values*/
          ctx2[0]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, t0);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (
        /*range*/
        ctx2[2]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_13(ctx2);
          if_block0.c();
          if_block0.m(div, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*pips*/
        ctx2[11]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*pips*/
          2048) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*id*/
      131072) {
        attr_dev(
          div,
          "id",
          /*id*/
          ctx2[17]
        );
      }
      if (!current || dirty[0] & /*range*/
      4) {
        toggle_class(
          div,
          "range",
          /*range*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      1024) {
        toggle_class(
          div,
          "disabled",
          /*disabled*/
          ctx2[10]
        );
      }
      if (!current || dirty[0] & /*hoverable*/
      512) {
        toggle_class(
          div,
          "hoverable",
          /*hoverable*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*vertical*/
      64) {
        toggle_class(
          div,
          "vertical",
          /*vertical*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*reversed*/
      256) {
        toggle_class(
          div,
          "reversed",
          /*reversed*/
          ctx2[8]
        );
      }
      if (!current || dirty[0] & /*focus*/
      33554432) {
        toggle_class(
          div,
          "focus",
          /*focus*/
          ctx2[25]
        );
      }
      if (!current || dirty[0] & /*range*/
      4) {
        toggle_class(
          div,
          "min",
          /*range*/
          ctx2[2] === "min"
        );
      }
      if (!current || dirty[0] & /*range*/
      4) {
        toggle_class(
          div,
          "max",
          /*range*/
          ctx2[2] === "max"
        );
      }
      if (!current || dirty[0] & /*pips*/
      2048) {
        toggle_class(
          div,
          "pips",
          /*pips*/
          ctx2[11]
        );
      }
      if (!current || dirty[0] & /*all, first, last, rest*/
      122880) {
        toggle_class(
          div,
          "pip-labels",
          /*all*/
          ctx2[13] === "label" || /*first*/
          ctx2[14] === "label" || /*last*/
          ctx2[15] === "label" || /*rest*/
          ctx2[16] === "label"
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      ctx[51](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function index(el) {
  if (!el)
    return -1;
  var i = 0;
  while (el = el.previousElementSibling) {
    i++;
  }
  return i;
}
function normalisedClient(e) {
  if (e.type.includes("touch")) {
    return e.touches[0] || e.changedTouches[0];
  } else {
    return e;
  }
}
function instance2($$self, $$props, $$invalidate) {
  let percentOf;
  let clampValue;
  let alignValueToStep;
  let orientationStart;
  let orientationEnd;
  let $springPositions, $$unsubscribe_springPositions = noop, $$subscribe_springPositions = () => ($$unsubscribe_springPositions(), $$unsubscribe_springPositions = subscribe(springPositions, ($$value) => $$invalidate(30, $springPositions = $$value)), springPositions);
  $$self.$$.on_destroy.push(() => $$unsubscribe_springPositions());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("RangeSlider", slots, []);
  let { slider = void 0 } = $$props;
  let { range = false } = $$props;
  let { pushy = false } = $$props;
  let { min = 0 } = $$props;
  let { max = 100 } = $$props;
  let { step = 1 } = $$props;
  let { values = [(max + min) / 2] } = $$props;
  let { vertical = false } = $$props;
  let { float = false } = $$props;
  let { reversed = false } = $$props;
  let { hoverable = true } = $$props;
  let { disabled = false } = $$props;
  let { pips = false } = $$props;
  let { pipstep = void 0 } = $$props;
  let { all = void 0 } = $$props;
  let { first = void 0 } = $$props;
  let { last = void 0 } = $$props;
  let { rest = void 0 } = $$props;
  let { id = void 0 } = $$props;
  let { prefix = "" } = $$props;
  let { suffix = "" } = $$props;
  let { formatter = (v, i, p) => v } = $$props;
  let { handleFormatter = formatter } = $$props;
  let { ariaLabels = [] } = $$props;
  let { precision = 2 } = $$props;
  let { springValues = { stiffness: 0.15, damping: 0.4 } } = $$props;
  const dispatch = createEventDispatcher();
  let valueLength = 0;
  let focus = false;
  let handleActivated = false;
  let handlePressed = false;
  let keyboardActive = false;
  let activeHandle = values.length - 1;
  let startValue;
  let previousValue;
  let springPositions;
  const fixFloat = (v) => parseFloat((+v).toFixed(precision));
  ;
  function targetIsHandle(el) {
    const handles = slider.querySelectorAll(".handle");
    const isHandle = Array.prototype.includes.call(handles, el);
    const isChild = Array.prototype.some.call(handles, (e) => e.contains(el));
    return isHandle || isChild;
  }
  function trimRange(values2) {
    if (range === "min" || range === "max") {
      return values2.slice(0, 1);
    } else if (range) {
      return values2.slice(0, 2);
    } else {
      return values2;
    }
  }
  function getSliderDimensions() {
    return slider.getBoundingClientRect();
  }
  function getClosestHandle(clientPos) {
    const dims = getSliderDimensions();
    let handlePos = 0;
    let handlePercent = 0;
    let handleVal = 0;
    if (vertical) {
      handlePos = clientPos.clientY - dims.top;
      handlePercent = handlePos / dims.height * 100;
      handlePercent = reversed ? handlePercent : 100 - handlePercent;
    } else {
      handlePos = clientPos.clientX - dims.left;
      handlePercent = handlePos / dims.width * 100;
      handlePercent = reversed ? 100 - handlePercent : handlePercent;
    }
    handleVal = (max - min) / 100 * handlePercent + min;
    let closest;
    if (range === true && values[0] === values[1]) {
      if (handleVal > values[1]) {
        return 1;
      } else {
        return 0;
      }
    } else {
      closest = values.indexOf(
        [...values].sort((a, b) => Math.abs(handleVal - a) - Math.abs(handleVal - b))[0]
      );
    }
    return closest;
  }
  function handleInteract(clientPos) {
    const dims = getSliderDimensions();
    let handlePos = 0;
    let handlePercent = 0;
    let handleVal = 0;
    if (vertical) {
      handlePos = clientPos.clientY - dims.top;
      handlePercent = handlePos / dims.height * 100;
      handlePercent = reversed ? handlePercent : 100 - handlePercent;
    } else {
      handlePos = clientPos.clientX - dims.left;
      handlePercent = handlePos / dims.width * 100;
      handlePercent = reversed ? 100 - handlePercent : handlePercent;
    }
    handleVal = (max - min) / 100 * handlePercent + min;
    moveHandle(activeHandle, handleVal);
  }
  function moveHandle(index2, value) {
    value = alignValueToStep(value);
    if (typeof index2 === "undefined") {
      index2 = activeHandle;
    }
    if (range) {
      if (index2 === 0 && value > values[1]) {
        if (pushy) {
          $$invalidate(0, values[1] = value, values);
        } else {
          value = values[1];
        }
      } else if (index2 === 1 && value < values[0]) {
        if (pushy) {
          $$invalidate(0, values[0] = value, values);
        } else {
          value = values[0];
        }
      }
    }
    if (values[index2] !== value) {
      $$invalidate(0, values[index2] = value, values);
    }
    if (previousValue !== value) {
      eChange();
      previousValue = value;
    }
    return value;
  }
  function rangeStart(values2) {
    if (range === "min") {
      return 0;
    } else {
      return values2[0];
    }
  }
  function rangeEnd(values2) {
    if (range === "max") {
      return 0;
    } else if (range === "min") {
      return 100 - values2[0];
    } else {
      return 100 - values2[1];
    }
  }
  function sliderBlurHandle(e) {
    if (keyboardActive) {
      $$invalidate(25, focus = false);
      handleActivated = false;
      $$invalidate(26, handlePressed = false);
    }
  }
  function sliderFocusHandle(e) {
    if (!disabled) {
      $$invalidate(27, activeHandle = index(e.target));
      $$invalidate(25, focus = true);
    }
  }
  function sliderKeydown(e) {
    if (!disabled) {
      const handle = index(e.target);
      let jump = e.ctrlKey || e.metaKey || e.shiftKey ? step * 10 : step;
      let prevent = false;
      switch (e.key) {
        case "PageDown":
          jump *= 10;
        case "ArrowRight":
        case "ArrowUp":
          moveHandle(handle, values[handle] + jump);
          prevent = true;
          break;
        case "PageUp":
          jump *= 10;
        case "ArrowLeft":
        case "ArrowDown":
          moveHandle(handle, values[handle] - jump);
          prevent = true;
          break;
        case "Home":
          moveHandle(handle, min);
          prevent = true;
          break;
        case "End":
          moveHandle(handle, max);
          prevent = true;
          break;
      }
      if (prevent) {
        e.preventDefault();
        e.stopPropagation();
      }
    }
  }
  function sliderInteractStart(e) {
    if (!disabled) {
      const el = e.target;
      const clientPos = normalisedClient(e);
      $$invalidate(25, focus = true);
      handleActivated = true;
      $$invalidate(26, handlePressed = true);
      $$invalidate(27, activeHandle = getClosestHandle(clientPos));
      startValue = previousValue = alignValueToStep(values[activeHandle]);
      eStart();
      if (e.type === "touchstart" && !el.matches(".pipVal")) {
        handleInteract(clientPos);
      }
    }
  }
  function sliderInteractEnd(e) {
    if (e.type === "touchend") {
      eStop();
    }
    $$invalidate(26, handlePressed = false);
  }
  function bodyInteractStart(e) {
    keyboardActive = false;
    if (focus && e.target !== slider && !slider.contains(e.target)) {
      $$invalidate(25, focus = false);
    }
  }
  function bodyInteract(e) {
    if (!disabled) {
      if (handleActivated) {
        handleInteract(normalisedClient(e));
      }
    }
  }
  function bodyMouseUp(e) {
    if (!disabled) {
      const el = e.target;
      if (handleActivated) {
        if (el === slider || slider.contains(el)) {
          $$invalidate(25, focus = true);
          if (!targetIsHandle(el) && !el.matches(".pipVal")) {
            handleInteract(normalisedClient(e));
          }
        }
        eStop();
      }
    }
    handleActivated = false;
    $$invalidate(26, handlePressed = false);
  }
  function bodyTouchEnd(e) {
    handleActivated = false;
    $$invalidate(26, handlePressed = false);
  }
  function bodyKeyDown(e) {
    if (!disabled) {
      if (e.target === slider || slider.contains(e.target)) {
        keyboardActive = true;
      }
    }
  }
  function eStart() {
    !disabled && dispatch("start", {
      activeHandle,
      value: startValue,
      values: values.map((v) => alignValueToStep(v))
    });
  }
  function eStop() {
    !disabled && dispatch("stop", {
      activeHandle,
      startValue,
      value: values[activeHandle],
      values: values.map((v) => alignValueToStep(v))
    });
  }
  function eChange() {
    !disabled && dispatch("change", {
      activeHandle,
      startValue,
      previousValue: typeof previousValue === "undefined" ? startValue : previousValue,
      value: values[activeHandle],
      values: values.map((v) => alignValueToStep(v))
    });
  }
  const writable_props = [
    "slider",
    "range",
    "pushy",
    "min",
    "max",
    "step",
    "values",
    "vertical",
    "float",
    "reversed",
    "hoverable",
    "disabled",
    "pips",
    "pipstep",
    "all",
    "first",
    "last",
    "rest",
    "id",
    "prefix",
    "suffix",
    "formatter",
    "handleFormatter",
    "ariaLabels",
    "precision",
    "springValues"
  ];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<RangeSlider> was created with unknown prop '${key}'`);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      slider = $$value;
      $$invalidate(1, slider);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("slider" in $$props2)
      $$invalidate(1, slider = $$props2.slider);
    if ("range" in $$props2)
      $$invalidate(2, range = $$props2.range);
    if ("pushy" in $$props2)
      $$invalidate(45, pushy = $$props2.pushy);
    if ("min" in $$props2)
      $$invalidate(3, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(4, max = $$props2.max);
    if ("step" in $$props2)
      $$invalidate(5, step = $$props2.step);
    if ("values" in $$props2)
      $$invalidate(0, values = $$props2.values);
    if ("vertical" in $$props2)
      $$invalidate(6, vertical = $$props2.vertical);
    if ("float" in $$props2)
      $$invalidate(7, float = $$props2.float);
    if ("reversed" in $$props2)
      $$invalidate(8, reversed = $$props2.reversed);
    if ("hoverable" in $$props2)
      $$invalidate(9, hoverable = $$props2.hoverable);
    if ("disabled" in $$props2)
      $$invalidate(10, disabled = $$props2.disabled);
    if ("pips" in $$props2)
      $$invalidate(11, pips = $$props2.pips);
    if ("pipstep" in $$props2)
      $$invalidate(12, pipstep = $$props2.pipstep);
    if ("all" in $$props2)
      $$invalidate(13, all = $$props2.all);
    if ("first" in $$props2)
      $$invalidate(14, first = $$props2.first);
    if ("last" in $$props2)
      $$invalidate(15, last = $$props2.last);
    if ("rest" in $$props2)
      $$invalidate(16, rest = $$props2.rest);
    if ("id" in $$props2)
      $$invalidate(17, id = $$props2.id);
    if ("prefix" in $$props2)
      $$invalidate(18, prefix = $$props2.prefix);
    if ("suffix" in $$props2)
      $$invalidate(19, suffix = $$props2.suffix);
    if ("formatter" in $$props2)
      $$invalidate(20, formatter = $$props2.formatter);
    if ("handleFormatter" in $$props2)
      $$invalidate(21, handleFormatter = $$props2.handleFormatter);
    if ("ariaLabels" in $$props2)
      $$invalidate(22, ariaLabels = $$props2.ariaLabels);
    if ("precision" in $$props2)
      $$invalidate(46, precision = $$props2.precision);
    if ("springValues" in $$props2)
      $$invalidate(47, springValues = $$props2.springValues);
  };
  $$self.$capture_state = () => ({
    spring,
    createEventDispatcher,
    RangePips: RangePips_default,
    slider,
    range,
    pushy,
    min,
    max,
    step,
    values,
    vertical,
    float,
    reversed,
    hoverable,
    disabled,
    pips,
    pipstep,
    all,
    first,
    last,
    rest,
    id,
    prefix,
    suffix,
    formatter,
    handleFormatter,
    ariaLabels,
    precision,
    springValues,
    dispatch,
    valueLength,
    focus,
    handleActivated,
    handlePressed,
    keyboardActive,
    activeHandle,
    startValue,
    previousValue,
    springPositions,
    fixFloat,
    index,
    normalisedClient,
    targetIsHandle,
    trimRange,
    getSliderDimensions,
    getClosestHandle,
    handleInteract,
    moveHandle,
    rangeStart,
    rangeEnd,
    sliderBlurHandle,
    sliderFocusHandle,
    sliderKeydown,
    sliderInteractStart,
    sliderInteractEnd,
    bodyInteractStart,
    bodyInteract,
    bodyMouseUp,
    bodyTouchEnd,
    bodyKeyDown,
    eStart,
    eStop,
    eChange,
    alignValueToStep,
    orientationEnd,
    orientationStart,
    clampValue,
    percentOf,
    $springPositions
  });
  $$self.$inject_state = ($$props2) => {
    if ("slider" in $$props2)
      $$invalidate(1, slider = $$props2.slider);
    if ("range" in $$props2)
      $$invalidate(2, range = $$props2.range);
    if ("pushy" in $$props2)
      $$invalidate(45, pushy = $$props2.pushy);
    if ("min" in $$props2)
      $$invalidate(3, min = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(4, max = $$props2.max);
    if ("step" in $$props2)
      $$invalidate(5, step = $$props2.step);
    if ("values" in $$props2)
      $$invalidate(0, values = $$props2.values);
    if ("vertical" in $$props2)
      $$invalidate(6, vertical = $$props2.vertical);
    if ("float" in $$props2)
      $$invalidate(7, float = $$props2.float);
    if ("reversed" in $$props2)
      $$invalidate(8, reversed = $$props2.reversed);
    if ("hoverable" in $$props2)
      $$invalidate(9, hoverable = $$props2.hoverable);
    if ("disabled" in $$props2)
      $$invalidate(10, disabled = $$props2.disabled);
    if ("pips" in $$props2)
      $$invalidate(11, pips = $$props2.pips);
    if ("pipstep" in $$props2)
      $$invalidate(12, pipstep = $$props2.pipstep);
    if ("all" in $$props2)
      $$invalidate(13, all = $$props2.all);
    if ("first" in $$props2)
      $$invalidate(14, first = $$props2.first);
    if ("last" in $$props2)
      $$invalidate(15, last = $$props2.last);
    if ("rest" in $$props2)
      $$invalidate(16, rest = $$props2.rest);
    if ("id" in $$props2)
      $$invalidate(17, id = $$props2.id);
    if ("prefix" in $$props2)
      $$invalidate(18, prefix = $$props2.prefix);
    if ("suffix" in $$props2)
      $$invalidate(19, suffix = $$props2.suffix);
    if ("formatter" in $$props2)
      $$invalidate(20, formatter = $$props2.formatter);
    if ("handleFormatter" in $$props2)
      $$invalidate(21, handleFormatter = $$props2.handleFormatter);
    if ("ariaLabels" in $$props2)
      $$invalidate(22, ariaLabels = $$props2.ariaLabels);
    if ("precision" in $$props2)
      $$invalidate(46, precision = $$props2.precision);
    if ("springValues" in $$props2)
      $$invalidate(47, springValues = $$props2.springValues);
    if ("valueLength" in $$props2)
      $$invalidate(48, valueLength = $$props2.valueLength);
    if ("focus" in $$props2)
      $$invalidate(25, focus = $$props2.focus);
    if ("handleActivated" in $$props2)
      handleActivated = $$props2.handleActivated;
    if ("handlePressed" in $$props2)
      $$invalidate(26, handlePressed = $$props2.handlePressed);
    if ("keyboardActive" in $$props2)
      keyboardActive = $$props2.keyboardActive;
    if ("activeHandle" in $$props2)
      $$invalidate(27, activeHandle = $$props2.activeHandle);
    if ("startValue" in $$props2)
      startValue = $$props2.startValue;
    if ("previousValue" in $$props2)
      previousValue = $$props2.previousValue;
    if ("springPositions" in $$props2)
      $$subscribe_springPositions($$invalidate(23, springPositions = $$props2.springPositions));
    if ("alignValueToStep" in $$props2)
      $$invalidate(49, alignValueToStep = $$props2.alignValueToStep);
    if ("orientationEnd" in $$props2)
      $$invalidate(28, orientationEnd = $$props2.orientationEnd);
    if ("orientationStart" in $$props2)
      $$invalidate(29, orientationStart = $$props2.orientationStart);
    if ("clampValue" in $$props2)
      $$invalidate(50, clampValue = $$props2.clampValue);
    if ("percentOf" in $$props2)
      $$invalidate(24, percentOf = $$props2.percentOf);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*min, max*/
    24) {
      $:
        $$invalidate(50, clampValue = function(val) {
          return val <= min ? min : val >= max ? max : val;
        });
    }
    if ($$self.$$.dirty[0] & /*min, max, step*/
    56 | $$self.$$.dirty[1] & /*clampValue*/
    524288) {
      $:
        $$invalidate(49, alignValueToStep = function(val) {
          if (val <= min) {
            return fixFloat(min);
          } else if (val >= max) {
            return fixFloat(max);
          } else {
            val = fixFloat(val);
          }
          let remainder = (val - min) % step;
          let aligned = val - remainder;
          if (Math.abs(remainder) * 2 >= step) {
            aligned += remainder > 0 ? step : -step;
          }
          aligned = clampValue(aligned);
          return fixFloat(aligned);
        });
    }
    if ($$self.$$.dirty[0] & /*min, max*/
    24) {
      $:
        $$invalidate(24, percentOf = function(val) {
          let perc = (val - min) / (max - min) * 100;
          if (isNaN(perc) || perc <= 0) {
            return 0;
          } else if (perc >= 100) {
            return 100;
          } else {
            return fixFloat(perc);
          }
        });
    }
    if ($$self.$$.dirty[0] & /*values, max, min, percentOf, springPositions, ariaLabels*/
    29360153 | $$self.$$.dirty[1] & /*alignValueToStep, valueLength, springValues*/
    458752) {
      $: {
        if (!Array.isArray(values)) {
          $$invalidate(0, values = [(max + min) / 2]);
          console.error("'values' prop should be an Array (https://github.com/simeydotme/svelte-range-slider-pips#slider-props)");
        }
        const trimmedAlignedValues = trimRange(values.map((v) => alignValueToStep(v)));
        if (!(values.length === trimmedAlignedValues.length) || !values.every((element2, index2) => fixFloat(element2) === trimmedAlignedValues[index2])) {
          $$invalidate(0, values = trimmedAlignedValues);
        }
        if (valueLength !== values.length) {
          $$subscribe_springPositions($$invalidate(23, springPositions = spring(values.map((v) => percentOf(v)), springValues)));
        } else {
          springPositions.set(values.map((v) => percentOf(v)));
        }
        $$invalidate(48, valueLength = values.length);
        if (values.length > 1 && !Array.isArray(ariaLabels)) {
          console.warn(`'ariaLabels' prop should be an Array (https://github.com/simeydotme/svelte-range-slider-pips#slider-props)`);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*vertical, reversed*/
    320) {
      $:
        $$invalidate(29, orientationStart = vertical ? reversed ? "top" : "bottom" : reversed ? "right" : "left");
    }
    if ($$self.$$.dirty[0] & /*vertical, reversed*/
    320) {
      $:
        $$invalidate(28, orientationEnd = vertical ? reversed ? "bottom" : "top" : reversed ? "left" : "right");
    }
  };
  return [
    values,
    slider,
    range,
    min,
    max,
    step,
    vertical,
    float,
    reversed,
    hoverable,
    disabled,
    pips,
    pipstep,
    all,
    first,
    last,
    rest,
    id,
    prefix,
    suffix,
    formatter,
    handleFormatter,
    ariaLabels,
    springPositions,
    percentOf,
    focus,
    handlePressed,
    activeHandle,
    orientationEnd,
    orientationStart,
    $springPositions,
    fixFloat,
    moveHandle,
    rangeStart,
    rangeEnd,
    sliderBlurHandle,
    sliderFocusHandle,
    sliderKeydown,
    sliderInteractStart,
    sliderInteractEnd,
    bodyInteractStart,
    bodyInteract,
    bodyMouseUp,
    bodyTouchEnd,
    bodyKeyDown,
    pushy,
    precision,
    springValues,
    valueLength,
    alignValueToStep,
    clampValue,
    div_binding
  ];
}
var RangeSlider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        slider: 1,
        range: 2,
        pushy: 45,
        min: 3,
        max: 4,
        step: 5,
        values: 0,
        vertical: 6,
        float: 7,
        reversed: 8,
        hoverable: 9,
        disabled: 10,
        pips: 11,
        pipstep: 12,
        all: 13,
        first: 14,
        last: 15,
        rest: 16,
        id: 17,
        prefix: 18,
        suffix: 19,
        formatter: 20,
        handleFormatter: 21,
        ariaLabels: 22,
        precision: 46,
        springValues: 47
      },
      add_css2,
      [-1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RangeSlider",
      options,
      id: create_fragment2.name
    });
  }
  get slider() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set slider(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get range() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set range(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pushy() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pushy(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get values() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set values(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get float() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set float(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get reversed() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set reversed(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hoverable() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hoverable(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pips() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pips(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pipstep() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pipstep(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get all() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set all(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get first() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set first(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get last() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set last(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rest() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rest(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get prefix() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set prefix(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get suffix() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set suffix(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get formatter() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set formatter(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get handleFormatter() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set handleFormatter(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ariaLabels() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ariaLabels(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get precision() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set precision(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get springValues() {
    throw new Error("<RangeSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set springValues(value) {
    throw new Error("<RangeSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var RangeSlider_default = RangeSlider;
export {
  RangeSlider_default as default
};
//# sourceMappingURL=svelte-range-slider-pips.js.map
